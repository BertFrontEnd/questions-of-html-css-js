<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" type="image/x-icon" href="./assets/favicon.ico" />
    <title>Questions of HTML, CSS & JavaScript</title>
    <link rel="stylesheet" href="style.css" />
  </head>

  <body>
    <section>
      <h2>The Rolling Scopes School. Первое собеседование на Stage 1</h2>
      <details>
        <summary>
          Подборка коротких статей, которые помогут подготовиться к
          собеседованию
        </summary>
        <div class="answer">
          <span></span>
          <ul class="answer__list">
            <li>Общая информация:</li>
            <li>
              <a
                href="https://docs.rs.school/#/technical-screening"
                target="_blank"
              >
                Собеседование с ментором. © The Rolling Scopes
              </a>
            </li>
            <li>
              <a
                href="https://github.com/rolling-scopes-school/tasks/blob/2018-Q3/tasks/technical-screening.md"
                target="_blank"
              >
                Technical screening. © GitHub
              </a>
            </li>
            <li>Вопросы и ссылки на ответы:</li>
            <li>
              <a href="https://habr.com/ru/post/87119" target="_blank">
                Основные понятия ООП (часть 1). © Хабр
              </a>
            </li>
            <li>
              <a href="https://habr.com/post/87205" target="_blank">
                Основные понятия ООП (часть 2). © Хабр
              </a>
            </li>
            <li>
              <a
                href="http://mathhelpplanet.com/static.php?p=javascript-algoritmy-sortirovki"
                target="_blank"
              >
                Алгоритмы сортировок на JavaScript (часть 2). © Математический
                форум Math Help Planet
              </a>
            </li>
            <li>
              <a href="https://proglib.io/p/sort-gif" target="_blank">
                Сортировки в гифках: 8 самых популярных алгоритмов. © Proglib
              </a>
            </li>
            <li>
              <a
                href="http://mathhelpplanet.com/static.php?p=javascript-algoritmy-poiska"
                target="_blank"
              >
                Алгоритмы поиска на JavaScript. © Математический форум Math Help
                Planet
              </a>
            </li>
            <li>
              <a
                href="https://verkholantsev.gitbooks.io/data-structures/content"
                target="_blank"
              >
                Структуры данных. © verkholantsev.gitbooks.io
              </a>
            </li>
            <li>
              <a
                href="http://mathematichka.ru/school/functions/Function_Graph_Table.html"
                target="_blank"
              >
                Элементарные функции и их графики. © mathematichka.ru
              </a>
            </li>
            <li>
              <a
                href="https://www.youtube.com/watch?v=FGRlYjHfzSY&feature=youtu.be"
                target="_blank"
              >
                Двоичная система счисления. © YouTube
              </a>
            </li>
            <li>
              <a href="https://habr.com/post/280125" target="_blank">
                REM vs EM. © Хабр
              </a>
            </li>
            <li>
              <a href="http://css.yoksel.ru/specifity" target="_blank">
                Сколько весят селекторы CSS?. © Хабр
              </a>
            </li>
            <li>
              <a
                href="http://htmlbook.ru/content/edinitsy-izmereniya"
                target="_blank"
              >
                Единицы измерения CSS. © htmlbook.ru
              </a>
            </li>
            <li>
              <a
                href="https://developer.mozilla.org/ru/docs/Web/CSS/box_model"
                target="_blank"
              >
                Боксовая модель CSS. © MDN web docs
              </a>
            </li>
            <li>
              <a href="https://habr.com/ru/post/104219" target="_blank">
                Оценка сложности алгоритмов. © Хабр
              </a>
            </li>
            <li>
              <a href="https://habr.com/ru/post/188010" target="_blank">
                Знай сложности алгоритмов. © Хабр
              </a>
            </li>
            <li>
              <a
                href="https://proglib.io/p/javascript-interview-handbook"
                target="_blank"
              >
                JavaScript-функции, объекты и типы данных: подготовка к
                интервью. © proglib
              </a>
            </li>
            <li>
              <a
                href="https://www.youtube.com/watch?v=t8zwdpkSRWs&list=PLKaafC45L_SQlY5ZNr6Dm0C0CcO2jx1-1"
                target="_blank"
              >
                Основы ООП. © YouTube
              </a>
            </li>
          </ul>
        </div>
      </details>
    </section>

    <section>
      <h2>HTML & СSS</h2>
      <details>
        <summary>
          1. Способы выравнивания блока по горизонтали и вертикали. Реализовать
          один из них
        </summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              - выравнивание с помощью
              <mark>таблицы</mark>
            </li>
            <li>
              - выравнивание с помощью
              <mark>отступов</mark>
            </li>
            <li>
              - выравнивание с помощью
              <mark>line-height</mark>
            </li>
            <li>
              - выравнивание с помощью
              <mark>растягивания</mark>
            </li>
            <li>
              - выравнивание с помощью отрицательного
              <mark>margin-top</mark>
            </li>
            <li>
              - выравнивание с помощью
              <mark>transform</mark>
            </li>
            <li>
              - выравнивание с помощью
              <mark>псевдоэлемента</mark>
            </li>
            <li>
              - выравнивание с помощью
              <mark>Flexbox</mark>
            </li>
            <li>
              <a
                href="https://habr.com/ru/company/netcracker/blog/277433"
                target="_blank"
              >
                Все способы вертикального выравнивания в CSS. © Хабр
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>2. Что такое псевдоэлементы и псевдоклассы?</summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              <mark>Псевдоэлемент</mark>
              - это виртуальный элемент, которым мы можем манипулировать как
              обычными html-элементами. Разница в том, что псевдоэлемент не
              существуют в дереве документа или DOM. Это значит что мы не пишем
              псевдоэлемент в html-разметке, а создаем их при помощи CSS
            </li>
            <li>
              <mark>Псевдокласс</mark>
              - это класс в основе которого лежит фантомное состояние элемента
              или его специфичная характеристика, управляемая через CSS
            </li>
            <li>
              <a
                href="https://medium.com/@ABatickaya/%D0%B8%D1%81%D1%87%D0%B5%D1%80%D0%BF%D1%8B%D0%B2%D0%B0%D1%8E%D1%89%D0%B5%D0%B5-%D1%80%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE-%D0%BF%D0%BE-%D0%BF%D1%81%D0%B5%D0%B2%D0%B4%D0%BE%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D0%BC-%D0%B8-%D0%BF%D1%81%D0%B5%D0%B2%D0%B4%D0%BE%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0%D0%BC-%D0%B2-css-3282b5ea029"
                target="_blank"
              >
                Исчерпывающее руководство по псевдоэлементам и псевдоклассам в
                CSS. © Medium
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>
          3. Какие основные свойства у псевдоэлемента after и before?
        </summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              <mark>Псевдоэлемент :before</mark>
              добавляет контент (текст или блок) перед другим html-элементом. И
              опять же, этот контент по факту не существует в DOM, но мы можем
              им управлять будто он есть. Обязательно должно быть объявлено
              CSS-свойство content. Текст, добавленный через псевдоэлемент, не
              может быть выбран пользователем
            </li>
            <li>
              <mark>Псевдоэлемент :after</mark>
              используется для добавления контента (текста или блока) после
              другого html-элемента. И опять же, этот контент по факту не
              существует в DOM, но мы можем им управлять будто он есть.
              Обязательно должно быть объявлено CSS-свойство content. Текст,
              добавленный через псевдоэлемент, не может быть выбран
              пользователем
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>
          4. Какие основные свойства у
          <s>элементов</s>
          display & content?
        </summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              <s>Элемент</s>
              <mark>display</mark>
              отвечает за вывод и визуальное отображение элементов на странице.
              Также с помощью свойства "display" можно изменить тип
              генерируемого контейнера. Свойство не наследуется
            </li>
            <li>
              <a href="https://html5book.ru/svoystvo-display" target="_blank">
                Свойство display. © HTML5BOOK.RU
              </a>
            </li>
            <li>
              <s>Элемент</s>
              <mark>content</mark>
              генерирует содержимое, которое визуально отображается на экране
              монитора, не добавляясь к дереву документа DOM. Программы для
              чтения с экрана не имеют доступ к содержимому, созданному с
              использованием псевдоэлементов и не могут его прочитать, поэтому
              рекомендуется не использовать псевдоэлементы для вставки важного
              контента на страницу
            </li>
            <li>
              <a href="https://html5book.ru/css-content" target="_blank">
                CSS content. © HTML5BOOK.RU
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>5. Чем отличается em от rem?</summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              <mark>em</mark>
              — в типографике относительная единица длины, равная размеру
              текущего шрифта. Это утверждение не имеет смысла в вебе, так как
              мы не используем размер точки (point-size). Но имеет смысл, если
              мы заменим размер точки на размер шрифта (font-size)
            </li>
            <li>
              <mark>rem</mark>
              — это корневой em (Root Em). Он создан, чтобы облегчить
              вычислительные проблемы, с которыми многие иногда сталкиваются.
              Это единица типографики, равная корневому (базовому) значению
              font-size. Это значит, что 1rem всегда будет равен значению
              font-size, которое было определено в html
            </li>
            <li>
              <a href="https://habr.com/ru/post/280125/" target="_blank">
                REM vs EM – Великий спор. © Хабр
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>6. Перечислить HTML5 теги</summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              -
              <mark>&lt;article&gt;</mark>
              определяет статью
            </li>
            <li>
              -
              <mark>&lt;aside&gt;</mark>
              определяет содержание в стороне от содержимого страницы
            </li>
            <li>
              -
              <mark>&lt;audio&gt;</mark>
              определяет звуковое содержимое
            </li>
            <li>
              -
              <mark>&lt;bdi&gt;</mark>
              изолирует часть текста, которая может быть отформатирована в
              другом направлении от другого текста за его пределами
            </li>
            <li>
              -
              <mark>&lt;canvas&gt;</mark>
              используется для рисования графики, на лету, с помощью сценариев
              (обычно JavaScript)
            </li>
            <li>
              -
              <mark>&lt;data&gt;</mark>
              связывает данное содержимое с машинно-читаемым переводом
            </li>
            <li>
              -
              <mark>&lt;datalist&gt;</mark>
              задает список предварительно заданных параметров для элементов
              управления вводом
            </li>
            <li>
              -
              <mark>&lt;details&gt;</mark>
              определяет дополнительные сведения, которые пользователь может
              просматривать или скрывать
            </li>
            <li>
              -
              <mark>&lt;dialog&gt;</mark>
              определяет диалоговое окно или окно
            </li>
            <li>
              -
              <mark>&lt;embed&gt;</mark>
              определяет контейнер для внешнего (не HTML) приложения
            </li>
            <li>
              -
              <mark>&lt;figcaption&gt;</mark>
              определяет заголовок для элемента
              <kbd>&lt;figure&gt;</kbd>
            </li>
            <li>
              -
              <mark>&lt;figure&gt;</mark>
              указывает автономное содержимое;
            </li>
            <li>
              -
              <mark>&lt;footer&gt;</mark>
              определяет нижний колонтитул для документа или раздела
            </li>
            <li>
              -
              <mark>&lt;header&gt;</mark>
              определяет заголовок документа или раздела
            </li>
            <li>
              -
              <mark>&lt;main&gt;</mark>
              указывает основное содержимое документа
            </li>
            <li>
              -
              <mark>&lt;mark&gt;</mark>
              определяет выделенный/выделенный текст
            </li>
            <li>
              -
              <mark>&lt;menuitem&gt;</mark>
              определяет команду/пункт меню, который пользователь может вызвать
              из всплывающего меню
            </li>
            <li>
              -
              <mark>&lt;meter&gt;</mark>
              определяет скалярное измерение в пределах известного диапазона
              (датчика)
            </li>
            <li>
              -
              <mark>&lt;nav&gt;</mark>
              определяет навигационные ссылки
            </li>
            <li>
              -
              <mark>&lt;output&gt;</mark>
              определяет результат вычисления
            </li>
            <li>
              -
              <mark>&lt;picture&gt;</mark>
              определяет контейнер для нескольких ресурсов изображения
            </li>
            <li>
              -
              <mark>&lt;progress&gt;</mark>
              представляет ход выполнения задачи
            </li>
            <li>
              -
              <mark>&lt;rp&gt;</mark>
              определяет, что отображать в обозревателях, не поддерживающих
              аннотации Ruby
            </li>
            <li>
              -
              <mark>&lt;rt&gt;</mark>
              определяет объяснение/произношение символов (для
              восточно-азиатских типографии)
            </li>
            <li>
              -
              <mark>&lt;ruby&gt;</mark>
              определяет аннотацию Ruby (для восточно-азиатских типографий)
            </li>
            <li>
              -
              <mark>&lt;section&gt;</mark>
              определяет раздел в документе
            </li>
            <li>
              -
              <mark>&lt;source&gt;</mark>
              определяет несколько мультимедийных ресурсов для элементов
              мультимедиа (
              <kbd>&lt;video&gt;</kbd>
              и
              <kbd>&lt;audio&gt;</kbd>
              )
            </li>
            <li>
              -
              <mark>&lt;summary&gt;</mark>
              определяет видимый заголовок для элемента
              <kbd>&lt;details&gt;</kbd>
            </li>
            <li>
              -
              <mark>&lt;template&gt;</mark>
              определяет шаблон
            </li>
            <li>
              -
              <mark>&lt;time&gt;</mark>
              определяет дату и время
            </li>
            <li>
              -
              <mark>&lt;track&gt;</mark>
              определяет текстовые дорожки для элементов мультимедиа (
              <kbd>&lt;video&gt;</kbd>
              и
              <kbd>&lt;audio&gt;</kbd>
              )
            </li>
            <li>
              -
              <mark>&lt;video&gt;</mark>
              определяет видео или фильм
            </li>
            <li>
              -
              <mark>&lt;wbr&gt;</mark>
              определяет возможный разрыв строки
            </li>
            <li>
              <a href="https://html5book.ru/html-tags" target="_blank">
                HTML-теги. © HTML5BOOK.RU
              </a>
            </li>
            <li>
              <a
                href="https://html5book.ru/examples/html-tags.html"
                target="_blank"
              >
                HTML 5.2. теги (имя тега, описание, значение свойства display).
                © HTML5BOOK.RU
              </a>
            </li>
            <li>
              <a href="https://html5css.ru/tags/default.php" target="_blank">
                HTML Справочник всех тегов онлайн и примеры. © HTML5CSS.ru
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>7. Какие есть виды селекторов и их приоритетность?</summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              -
              <mark>универсальный</mark>
              селектор, например,
              <kbd>* {...;}</kbd>
            </li>
            <li>
              - селектор
              <mark>элемента</mark>
              , например,
              <kbd>h1 {...;}</kbd>
              ;
            </li>
            <li>
              - селектор
              <mark>класса</mark>
              , например,
              <kbd>.headline {...;}</kbd>
            </li>
            <li>
              - селектор
              <mark>идентификатора</mark>
              , например,
              <kbd>#sidebar {...;}</kbd>
            </li>
            <li>
              - селектор
              <mark>потомка</mark>
              , например,
              <kbd>ul li {...;}</kbd>
            </li>
            <li>
              -
              <mark>дочерний</mark>
              селектор, например,
              <kbd>p > strong {...;}</kbd>
            </li>
            <li>
              -
              <mark>сестринский</mark>
              селектор, например,
              <kbd>h1 + p {...;}</kbd>
              и
              <kbd>h1 ~ p {...;}</kbd>
              ;
            </li>
            <li>
              - селектор
              <mark>атрибута</mark>
              , например,
              <kbd>img[alt] {...;}</kbd>
            </li>
            <li>
              - селектор
              <mark>псевдокласса</mark>
              , например,
              <kbd>a:link {...;}</kbd>
            </li>
            <li>
              - селектор
              <mark>структурных псевдоклассов</mark>
              , например,
              <kbd>:nth-child(odd) {...;}</kbd>
            </li>
            <li>
              - селектор
              <mark>структурных псевдоклассов типа</mark>
              , например,
              <kbd>:nth-of-type() {...;}</kbd>
            </li>
            <li>
              - селектор
              <mark>псевдоэлемента</mark>
              , например,
              <kbd>:before {...;}</kbd>
            </li>
            <li>
              <a href="https://html5book.ru/osnovy-css/#part2" target="_blank">
                Виды селекторов. © HTML5BOOK.RU
              </a>
            </li>
            <li>
              - самый высокий приоритет имеет атрибут
              <mark>style</mark>
              . Это правило перекрывает все селекторы описанные в стилях
            </li>
            <li>
              - второе место занимает присутствие
              <mark>ID</mark>
              в селекторе, например,
              <kbd>#some-id</kbd>
            </li>
            <li>
              - далее идут все атрибуты (в том числе и атрибут
              <mark>class</mark>
              ) и псевдоклассы (
              <mark>pseudo-classes</mark>
              ) в селекторе
            </li>
            <li>
              - самый низкий приоритет у селекторов с именами элементов и
              псевдоэлементами (
              <mark>pseudo-elements</mark>
              )
            </li>
            <li>
              <a
                href="http://www.quizful.net/post/specificity-of-css-selectors"
                target="_blank"
              >
                Приоритетность селекторов в CSS. © <em>quizful</em>
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>8. Как подключить свой шрифт на страницу?</summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              - через HTML с помощью элемента
              <kbd>&lt;link&gt;</kbd>
              в
              <kbd>&lt;head&gt;</kbd>
              документа
            </li>
            <li>
              - через CSS с помощью директив
              <kbd>@import</kbd>
              и
              <kbd>@font-face</kbd>
            </li>
            <li>
              <a
                href="https://proverstka.com.ua/services/podklyuchenie-shrifta-k-html-stranice"
                target="_blank"
              >
                Подключение шрифта к html странице. © ПРОВЁРСТКА
              </a>
            </li>
            <li>
              <a
                href="https://www.cat-in-web.ru/podklyuchenie-shriftov-v-css"
                target="_blank"
              >
                Подключение шрифтов в CSS. © CAT.IN.WEB
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>9. Что такое Grid? Нарисовать сетку 3x3</summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              <mark>Grid</mark>, иначе <mark>CSS Grid Layout</mark> представляет
              собой пересекающийся набор горизонтальных и вертикальных линий -
              один набор определяет столбцы, а другой строки. Элементы могут
              быть помещены в сетку, соответственно строкам и столбцам
            </li>
            <li>
              <a
                href="https://habr.com/ru/company/edison/blog/343614"
                target="_blank"
              >
                Учим CSS Grid за 5 минут. © Хабр
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>
          10. В чем отличие блочного и строчного элемента? Примеры блочных и
          строчных элементов
        </summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              <mark>Блочные элементы</mark> являются основой, которая
              используется для верстки веб-страниц. Такой элемент представляет
              собой прямоугольник, который по умолчанию занимает всю доступную
              ширину страницы (если иное значение не указано в CSS), а длина
              элемента зависит от его содержимого. Такой элемент всегда
              начинается с новой строки, то есть, располагается под предыдущим
              элементом. Блочный элемент может содержать в себе другие блочные и
              строчные элементы. Примеры <mark>блочных элементов</mark>:
              <kbd>&lt;div&gt;</kbd>, <kbd>&lt;p&gt;</kbd>,
              <kbd>&lt;ul&gt;</kbd>, <kbd>&lt;ol&gt;</kbd>,
              <kbd>&lt;h1&gt;</kbd> и т. д.
            </li>
            <li>
              В отличие от блочного, <mark>строчный элемент</mark> не
              переносится на новую строку, а располагается на той же строке, что
              и предыдущий элемент. Такие элементы, как правило, находятся
              внутри блочных элементов и их ширина зависит лишь от содержимого и
              настроек CSS. Еще одно отличие строчного элемента от блочного
              заключается к том, что в нем может находиться только контент и
              другие строчные элементы. Блочные элементы в строчные вкладывать
              нельзя. Примеры <mark>строчных элементов</mark>:
              <kbd>&lt;a&gt;</kbd>, <kbd>&lt;span&gt;</kbd>,
              <kbd>&lt;strong&gt;</kbd>, <kbd>&lt;em&gt;</kbd>,
              <kbd>&lt;img&gt;</kbd> и т. д.
            </li>
            <li>
              <a
                href="https://idg.net.ua/blog/uchebnik-css/ispolzovanie-css/block-i-inline"
                target="_blank"
              >
                Блочные и строчные элементы. © INDIGO
              </a>
            </li>
            <li>
              <a
                href="https://html5book.ru/block-inline-elements"
                target="_blank"
              >
                Блочные и строчные элементы. © HTML5BOOK.RU
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>
          11. Свойство float. Какие есть с ним проблемы и как решаются?
        </summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              <mark>Float</mark> — это условно коробка, которая двигается вправо
              или влево по текущей линии. Наиболее интересная характеристика
              float в том, что контент может обтекать вдоль его стороны. При
              применении свойства float: left, контент будет обтекать коробку
              вниз с правой стороны и аналогично при <kbd>float: right</kbd> -
              вниз с левой стороны
            </li>
            <li>
              <a
                href="http://www.css-tricks.ru/articles/css/all-about-floats"
                target="_blank"
              >
                Всё о свойстве float. © CSS<em>tricks</em>
              </a>
            </li>
            <li>
              <a href="https://habr.com/ru/post/142486" target="_blank">
                Подробно о свойстве float. © Хабр
              </a>
            </li>
            <li>
              <a href="http://www.quizful.net/post/css-floats" target="_blank">
                CSS: свойство float. © <em>quizful</em>
              </a>
            </li>
            <li>
              <mark>Проблема 1:</mark> обтекание влияет на другие элементы
            </li>
            <li>
              <mark>Проблема 2:</mark> нулевая высота контейнера с
              float-элементами
            </li>
            <li>
              <mark>Проблема 3:</mark> перенос блоков при добавлении отступов
            </li>
            <li>
              <a
                href="https://idg.net.ua/blog/uchebnik-css/razmetka-css/verstka-s-float/problemy"
                target="_blank"
              >
                Проблемы float и их решения. © INDIGO
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>
          12. Adaptive & Responsive layout — адаптивный и отзывчивый дизайн.
          Особенности и отличия
        </summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              <mark>Responsive Design (RWD) — отзывчивый дизайн</mark> —
              проектирование сайта с определенными значениями свойств, например,
              гибкая сетка макета, которые позволяют одному макету работать на
              разных устройствах
            </li>
            <li>
              <mark
                >Adaptive Design (AWD) — адаптивный дизайн, или динамический
                показ</mark
              >
              — проектирование сайта с условиями, которые изменяются в
              зависимости от устройства, базируясь на нескольких макетах
              фиксированной ширины
            </li>
            <li>
              Для создания отзывчивых макетов используются медиазапросы и
              относительные размеры элементов сетки, заданные с помощью
              <kbd>%</kbd>. В адаптивном дизайне серверные скрипты сначала
              определяют тип устройства, с помощью которого пользователь
              пытается получить доступ к сайту (настольный ПК, телефон или
              планшет), затем загружает именно ту версию страницы, которая
              наиболее оптимизирована для него. Для элементов сетки задаются
              фиксированные <kbd>px</kbd> размеры. Поэтому основное отличие
              между этими приёмами — <mark>отзывчивый дизайн</mark> — один макет
              для всех устройств, <mark>адаптивный дизайн</mark> — один макет
              для каждого вида устройства.
            </li>
            <li>
              <a
                href="https://html5book.ru/otzyvchivyj-dizayn-saita"
                target="_blank"
              >
                Отзывчивый и адаптивный дизайн сайта. © HTML5BOOK.RU
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>
          13. Как сделать сайт резиновым/отзывчивым под все размеры устройств?
          Использование rem em, vh vw, vmax vmin
        </summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              Отзывчивый веб-дизайн разбивается на три основных компонента,
              включая <mark>гибкие макеты</mark>, <mark>медиа-запросы</mark> и
              <mark>гибкий медиа-контент</mark>. Первая часть, гибкие макеты —
              это практика построения макета сайта с гибкой сеткой, которая
              способна динамически уменьшать размер до любой ширины. Гибкие
              сетки строятся с использованием относительных единиц длины, как
              правило, <kbd>%</kbd> или единиц <kbd>em</kbd> / <kbd>rem</kbd> /
              <kbd>vh</kbd> - <kbd>vw</kbd> / <kbd>vmax</kbd> - <kbd>vmin</kbd>.
              Эти относительные длины затем применяются, чтобы объявить основные
              значения свойств сетки, таких как <kbd>width</kbd>,
              <kbd>margin</kbd> или <kbd>padding</kbd>.
            </li>
            <li>
              <a
                href="https://webref.ru/layout/advanced-html-css/responsive-web-design"
                target="_blank"
              >
                Отзывчивый веб-дизайн. © WebReference
              </a>
            </li>
            <li>
              <a
                href="http://site-on.net/create/html/7-responsive"
                target="_blank"
              >
                Пошаговое руководство по созданию <s>адаптивного</s> отзывчивого
                дизайна. © Site <em>on!</em>
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>
          14. В чем разница между <kbd>display: none</kbd> и
          <kbd>visibility: hidden</kbd>?
        </summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              <kbd>visibility: hidden</kbd> – элемент остается в естественном
              потоке документа
            </li>
            <li>
              <kbd>display: none</kbd> – элемент удаляется из естественного
              потока документа и окружающие его элементы html, схлопываясь,
              заполняют образовавшееся пространство
            </li>
            <li>
              <a href="http://dnzl.ru/view_post.php?id=175" target="_blank">
                Visibility или Display в CSS. © DNZL.RU
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>15. @media в сss. Что это и как используется?</summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              В общем случае, <mark>медиа-запрос</mark>
              <kbd>@media</kbd> состоит из ключевого слова, описывающего тип
              устройства (необязательный параметр) и выражения, проверяющего
              характеристики данного устройства. Из всех характеристик чаще
              всего проверяется ширина устройства <kbd>width</kbd>. Медиа-запрос
              является логическим выражением, которое возвращает истину или ложь
            </li>

            <li>
              <a href="https://html5book.ru/css3-mediazaprosy" target="_blank">
                CSS3-медиазапросы. © HTML5BOOK.RU
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>
          16. Использование различных стилей для устройств с различным размером
          экрана: <kbd>min</kbd>, <kbd>max</kbd>, <kbd>width</kbd>,
          <kbd>screen</kbd>, <kbd>display</kbd>, <kbd>print</kbd>, phone:
          <kbd>landscape</kbd>,
          <kbd>portrait</kbd>
        </summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              Все запросы начинаются с правила <kbd>@media</kbd>, после чего
              следует условие, в котором используются
              <mark>типы носителей</mark>, <mark>логические</mark>
              <mark>операторы</mark> и <mark>медиа-функции</mark>
            </li>
            <li>
              <a href="http://htmlbook.ru/css/value/media" target="_blank">
                Медиа-запросы. © htmlbook.ru
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>17. Что такое SASS? Возможности и фишки</summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              <mark>Sass — Syntactically Awesome Stylesheets</mark> — это
              скриптовый метаязык, разработанный для упрощения файлов CSS. Этот
              модуль входит в Haml (HTML abstraction markup language), который
              используется для упрощения HTML
            </li>
            <li>Основные <mark>преимущества</mark> Sass:</li>
            <li>- использование переменных</li>
            <li>- вложенные правила</li>
            <li>- использование дополнений</li>
            <li>- наследование</li>
            <li>
              <a
                href="https://timeweb.com/ru/community/articles/chto-takoe-sass-1"
                target="_blank"
              >
                Что такое Sass. © timeweb.com
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>18. Что такое @mixin?</summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              <kbd>@mixin</kbd>, иначе говоря, <mark>миксин</mark> или
              <mark>примесь</mark> — это директива позволяющая создавать
              переиспользуемые блоки CSS. Чтобы использовать миксин, его
              необходимо подключить в Sass файле c помощью директивы
              <kbd>@include</kbd>
            </li>
            <li>
              <a
                href="https://timeweb.com/ru/community/articles/chto-takoe-sass-1"
                target="_blank"
              >
                Основы Sass. Миксины. © .getInstance
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>19. Как подключить .css файл в .html?</summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              - подключение CSS через внешний файл стилей тегом <kbd>link</kbd>
            </li>
            <li>- добавление CSS с помощью тега <kbd>style</kbd></li>
            <li>- CSS стили для конкретного тега атрибутом <kbd>style</kbd></li>
            <li>- стили CSS через JavaScript</li>
            <li>
              <a
                href="https://guruweba.com/html/podklyuchenie-stiley-css-k-html-dokumentu-kak-podkuchit-css-fail"
                target="_blank"
              >
                Подключение стилей CSS к HTML документу. Как подключить CSS
                файл. © GuruWeba
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>
          20. Схлопывание <kbd>margin</kbd>. Что это и как избежать?
        </summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              Эффект схлопывания наблюдается, когда у блочных элементов
              расположенных рядом друг с другом по вертикали, отступы не
              суммируются, а объединяются между собой. Само схлопывание
              действует на два и более блока (один может быть вложен внутрь
              другого) с отступами сверху или снизу, при этом примыкающие
              отступы комбинируются в один.
              <mark
                >Этот эффект работает только для блоков, у которых не заданы
                поля и границы. Для отступов слева и справа схлопывание никогда
                не применяется</mark
              >
            </li>

            <li>
              Правила вычисления единого отступа меняются в зависимости от ряда
              условий:
            </li>

            <li>- оба отступа положительны</li>
            <li>- один из отступов отрицательный</li>
            <li>- вложенные элементы</li>
            <li>Схлопывание не срабатывает:</li>
            <li>
              - для элементов, у которых установлено свойство
              <kbd>padding</kbd>.
            </li>
            <li>
              - для элементов, у которых на стороне схлопывания задана граница;
            </li>
            <li>
              - на элементах с абсолютным позиционированием, т.е. таких, у
              которых <kbd>position</kbd> установлено как <kbd>absolute</kbd>;
            </li>
            <li>
              - на плавающих элементах (для них свойство <kbd>float</kbd> задано
              как <kbd>left</kbd> или <kbd>right</kbd>);
            </li>
            <li>- для строчных элементов;</li>
            <li>- для <kbd>&lt;html&gt;</kbd></li>
            <li>
              Также схлопывание не срабатывает при соблюдении некоторых условий:
            </li>
            <li>
              - для элементов, у которых значение <kbd>overflow</kbd> задано как
              <kbd>auto</kbd>, <kbd>hidden</kbd> или
              <kbd>scroll</kbd> схлопывание не действует для их дочерних
              элементов;
            </li>
            <li>
              - у элементов, к которым применяется свойство <kbd>clear</kbd>, не
              схлопывается верхний отступ с нижним отступом родительского
              элемента.
            </li>
            <li>
              <a
                href="http://htmlbook.ru/samlayout/blochnaya-verstka/skhlopyvayushchiesya-otstupy"
                target="_blank"
              >
                Схлопывающиеся отступы. © htmlbook.ru
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>
          21. Как сделать так, что бы <kbd>border</kbd> учитывался в заданной
          ширине элемента?
        </summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              Чтобы браузер учитывал отступы и рамку, вычисляя ширину блока,
              используется свойство <kbd>box-sizing</kbd> со значением
              <kbd>border-box</kbd> — в данном случае браузер включает отступы
              <kbd>padding</kbd> и рамку <kbd>border</kbd> в общую ширину/высоту
              элемента.
            </li>
            <li>
              <a
                href="https://guruweba.com/html/podklyuchenie-stiley-css-k-html-dokumentu-kak-podkuchit-css-fail"
                target="_blank"
              >
                Box-sizing: управляем вычислением ширины и высоты. © INDIGO
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>
          22. Семантическая верстка. Что это и зачем? Способы семантической
          верстки
        </summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              <mark>Семантическая вёрстка</mark>
              , или
              <mark>семантический HTML-код</mark>
              , — это подход к созданию веб-страниц на языке HTML, основанный на
              использовании HTML-тегов в соответствии с их семантикой, а также
              предполагающий логичную и последовательную иерархию страницы
            </li>
            <li>
              <mark>Семантическая вёрстка</mark>
              и разметка позволяет более точно определять значимость отдельных
              элементов веб-страницы и всего текста в целом Поэтому, прежде
              всего –
              <mark>семантическая вёрстка нужна</mark>
              для улучшения робото-функционала сайта и, как следствие – лучшей
              его поисковой индексации
            </li>
            <li>
              <a
                href="http://tehnopost.info/html/74-html5-semanticheskaya-razmetka-sayta.html"
                target="_blank"
              >
                HTML5 | Семантическая разметка сайта. © tehnopost.info
              </a>
            </li>
            <li>
              Для получения
              <mark>семантической верстки</mark>
              необходимо:
            </li>
            <li>
              - на одной HTML странице подключать только один CSS файл и один JS
              файл
            </li>
            <li>
              - как можно больше все выносить в CSS стили, а JS код в отдельный
              файл
            </li>
            <li>
              - при создании меню лучше всего использовать
              <kbd>&lt;ul&gt;</kbd>
              список, внутри которого будут лежать
              <kbd>&lt;li&gt;</kbd>
              элементы меню. Этим мы показываем, что ссылки равносильные. Если
              имеются пункты второй вложенности, соответственно создаем внутри
              первичного
              <kbd>&lt;li&gt;</kbd>
              элемента еще один
              <kbd>&lt;ul&gt;</kbd>
              список
            </li>
            <li>
              - заголовки выделять тегами
              <kbd>&lt;h1&gt;</kbd>
              ,
              <kbd>&lt;h2&gt;</kbd>
              ,
              <kbd>&lt;h3&gt;</kbd>
              ,
              <kbd>&lt;h4&gt;</kbd>
              , но никак не
              <kbd>&lt;b&gt;</kbd>
              и
              <kbd>&lt;strong&gt;</kbd>
            </li>
            <li>
              - все служебные картинки (иконки, стрелки, пульки…) прописывать в
              CSS коде. В HTML, тег
              <kbd>&lt;img&gt;</kbd>
              должен использоваться только для больших картинок. Большие,
              понятие растяжимое, скажем так, начиная с превьюшек 100 x 100 и
              выше
            </li>
            <li>
              - параграф блока текста создавать с помощью
              <kbd>&lt;p&gt;</kbd>
              тега, но никак не
              <kbd>&lt;div&gt;</kbd>
            </li>
            <li>
              - не использовать атрибуты
              <kbd>&lt;style&gt;</kbd>
              внутри HTML тега. Все стили выносить в отдельный CSS файл. То же
              самое по поводу JavaScript
            </li>
            <li>
              - соблюдать иерархию и логику документа. Более важные элементы
              страницы должны стоять в начале HTML кода, менее в конце. С
              помощью CSS стилей и
              <kbd>&lt;div&gt;</kbd>
              блоков, этого достичь не сложно, при любой схеме шаблона.
            </li>
            <li>
              <a
                href="https://sitear.ru/material/semanticheskaya-verstka-semanticheskogo-koda"
                target="_blank"
              >
                Семантическая верстка: понятие и примеры семантического кода. ©
                SiteAR
              </a>
            </li>
            <li>
              <a
                href="https://www.cat-in-web.ru/podklyuchenie-shriftov-v-css"
                target="_blank"
              >
                Секреты использования семантической̆ верстки в HTML5. © Medium
              </a>
            </li>
            <li>
              <a
                href="https://html5book.ru/html5-semantic-elements- "
                target="_blank"
              >
                Семантические элементы HTML5. © HTML5BOOK.RU
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>23. Что такое поток?</summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              Любой HTML документ отображается в браузере пользователя в
              соответствии с определенными правилами. На эти правила влияют
              последовательность элементов в коде страницы и свойства этих
              элементов. На основе эти правил браузер последовательно и
              методично выводит каждый элемент документа. Порядок отображения
              элементов на странице и называют
              <mark>потоком</mark>
            </li>
            <li>
              -
              <mark>нормальный</mark>
              поток (
              <mark>normal</mark>
              flow)
            </li>
            <li>
              -
              <mark>плавающий</mark>
              поток (
              <mark>float</mark>
              flow)
            </li>
            <li>
              -
              <mark>абсолютное позиционирование</mark>
              (
              <mark>absolute positioning</mark>
              )
            </li>
            <li>
              <a href="http://webdesignstudio1.net/flows.html" target="_blank">
                Потоки HTML документа. © WebDesignStudio.net
              </a>
            </li>
            <li>
              <a
                href="https://webref.ru/course/positioning/flow"
                target="_blank"
              >
                Поток. © WebReference
              </a>
            </li>
          </ul>
        </div>
      </details>
    </section>

    <section>
      <h2>JavaScript</h2>
      <details>
        <summary>
          1. Что такое <kbd>SetTimeout</kbd> и <kbd>SetInterval</kbd>? Как это
          отменить?
        </summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              В JavaScript есть две функции для отложенного запуска кода:
              <mark>SetTimeout</mark> и <mark>SetInterval</mark>. Отличаются они
              тем, что <mark>SetTimeout</mark> запускает код
              <mark>единожды</mark>, а <mark>SetInterval</mark> —
              <mark>постоянно</mark> с заданной периодичностью.
            </li>
            <li>
              Обе функции первым аргументом принимают строку кода, которую
              необходимо выполнить, или функцию, которую необходимо запустить.
              Второй аргумент задаёт задержку в миллисекундах. Возвращают обе
              функции идентификатор созданного таймера.
            </li>
            <li>
              Действие функций <mark>SetTimeout</mark> и
              <mark>SetInterval</mark> можно отменить функциями
              <mark>clearTimeout</mark> и
              <mark>clearInterval</mark> соответственно, передавая последним
              идентификатор отключаемого таймера.
            </li>
            <li>
              <a
                href="http://alljs.ru/articles/timeout/overview"
                target="_blank"
              >
                Функции setTimeout и setInterval. © alljs.ru
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>2. Отличие <kbd>==</kbd> и <kbd>===</kbd> ?</summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              Оператор
              <kbd>==</kbd>
              сравнивает на равенство, а вот
              <kbd>===</kbd>
              — на идентичность. Плюс оператора
              <kbd>===</kbd>
              состоит в том, что он не приводит два значения к одному типу.
              Именно из-за этого он обычно и используется.
            </li>
            <li>
              <a href="https://habr.com/ru/post/138272" target="_blank">
                Отличия == и === в JavaScript. © Хабр
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>3. Основные фишки ES6</summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              1. <kbd>let</kbd>, <kbd>const</kbd> и блочная область видимости
            </li>
            <li>2. Стрелочные функции</li>
            <li>3. Параметры по умолчанию</li>
            <li>4. Spread / Rest оператор</li>
            <li>5. Расширение возможностей литералов объекта</li>
            <li>6. Восьмеричный и двоичный литералы</li>
            <li>7. Деструктуризация массивов и объектов</li>
            <li>8. Ключевое слово super для объектов</li>
            <li>9. Строковые шаблоны и разделители</li>
            <li>10. <kbd>for...of</kbd> против <kbd>for...in</kbd></li>
            <li>11. Map и WeakMap</li>
            <li>12. Set и WeakSet</li>
            <li>13. Классы в ES6</li>
            <li>14. Тип данных Symbol</li>
            <li>15. Итераторы</li>
            <li>16. Генераторы</li>
            <li>17. Промисы</li>
            <li>
              <a href="https://habr.com/ru/post/305900" target="_blank">
                ES6 по-человечески. © Хабр
              </a>
            </li>
            <li>
              <a
                href="https://github.com/etnolover/ES6-for-humans-translation"
                target="_blank"
              >
                ES6 по-человечески. © GitHub
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>
          4. Function Declaration (объявление функций) & Function Expression
          (функциональное выражение). Отличия
        </summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li><mark>Function Declaration</mark> (объявление функций):</li>
            <li><kbd>function hello(param) { console.log(param); };</kbd></li>
            <li><kbd>hello('Hi');</kbd></li>
            <li>
              <mark>Function Expression</mark> (функциональное выражение):
            </li>
            <li>
              <kbd>let hello = function(param) { console.log(param); };</kbd>
            </li>
            <li><kbd>hello('Hi');</kbd></li>
            <li>
              <mark>Отличие</mark> Function Declaration от Function Expression
              заключается в том, что при
              <mark>декларировании</mark> (объявлении) функции, она (функция)
              создается до выполнения остального кода. Соответственно, к моменту
              начала выполнения кода все <mark>задекларированные</mark> функции
              уже созданы и доступны к использованию. В случае же с
              <mark>функциональным</mark> выражением функции будут создаваться
              только в момент выполнения кода, а не перед ним
            </li>
            <li>
              <a
                href="https://webformyself.com/function-declaration-i-function-expression-v-javascript/"
                target="_blank"
              >
                Function Declaration и Function Expression в JavaScript. ©
                Webfor<em>Myself</em>
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>
          5. Параметры и аргументы и функции. Аргументы при вызове функции.
          Параметры в теле функции
        </summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              <mark>Параметры</mark> функции — это <mark>имена</mark>,
              перечисленные в определении функции.
            </li>
            <li>
              При вызове функции, ей могут передаваться значения, которыми будут
              инициализированы параметры. Значения, которые передаются при
              вызове функции называются <mark>аргументами</mark>.
              <mark>Аргументы</mark>, указываются через запятую. Иными словам,
              <mark>аргументы</mark> функции — это реальные
              <mark>значения</mark>, передаваемые (и получаемые) функцией.
            </li>
            <li>Поведение <mark>аргументов</mark> при вызове функции:</li>
            <li>
              - аргументы присваиваются параметрам функции в том порядке, в
              каком они указаны
            </li>
            <li>
              - если при вызове функции ей передаётся больше аргументов, чем
              задано параметров, "лишние" аргументы просто не присваиваются
              параметрам
            </li>
            <li>
              - если функция имеет больше параметров, чем передано ей
              аргументов, то параметрам без соответствующих аргументов
              присваивается значение <kbd>undefined</kbd>.
            </li>

            <li>
              - если функция вызывается с
              <mark>отсутствующими</mark> аргументами (меньше, чем объявлено),
              то отсутствующие значения имеют значение: не определено
            </li>
            <li>
              - если функция вызывается с
              <mark>слишком большим количеством аргументов</mark> (более чем
              объявлено), Эти аргументы могут быть достигнуты с помощью
              <mark>объекта arguments</mark>, который содержит массив
              аргументов.
            </li>
            <li>
              - аргументы передаются по значению. Изменения аргументов
              <mark>не отображаются</mark> вне функции.
            </li>
            <li>
              - объекты передаются по ссылке. Изменения свойств объекта
              <mark>видимы</mark> вне функции.
            </li>

            <li><mark>Параметры</mark> в теле функции:</li>
            <li>
              - все функции имеют два неявных параметра: <kbd>arguments</kbd> и
              <kbd>this</kbd>
            </li>
            <li>
              - имеют значения по
              <a
                href="https://puzzleweb.ru/javascript/13_functions2.php#a1"
                target="_blank"
                >умолчанию</a
              >
            </li>
            <li>
              - имеют
              <a
                href="https://puzzleweb.ru/javascript/13_functions2.php#a2"
                target="_blank"
                >дополнительный</a
              >
              параметр
            </li>
            <li>Правила <mark>параметров</mark>:</li>
            <li>
              - определения функций JavaScript не указывают типы данных для
              параметров
            </li>
            <li>
              - функции JavaScript не выполняют проверку типа на передаваемых
              аргументах
            </li>
            <li>
              - функции JavaScript не проверяют количество полученных аргументов
            </li>
            <li>
              <a
                href="https://html5css.ru/js/js_function_parameters.php"
                target="_blank"
              >
                JavaScript Параметры функции. © HTML5CSS.ru
              </a>
            </li>
            <li>
              <a
                href="https://puzzleweb.ru/javascript/13_functions2.php"
                target="_blank"
              >
                JavaScript: Параметры и аргументы функции. © PuzzleWeb.ru
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>8. Что такое наследование? Примеры наследования</summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              JavaScript использует <mark>прототипное наследование</mark>. Это
              означает, что в JavaScript объекты наследуются от других объектов.
              Простые объекты в JavaScript, созданные с использованием
              <kbd>{...}</kbd> фигурных скобок, имеют только один прототип:
              <kbd>Object.prototype</kbd>. <kbd>Object.prototype</kbd>, в свою
              очередь тоже объект, и все свойства и методы
              <kbd>Object.prototype</kbd> доступны для всех объектов
            </li>
            <li>
              Массивы, созданные с помощью <kbd>[]</kbd> квадратных скобок,
              имеют несколько прототипов, в том числе
              <kbd>Object.prototype</kbd> и <kbd>Array.prototype</kbd>. Это
              означает, что все свойства и методы <kbd>Object.prototype</kbd> и
              <kbd>Array.prototype</kbd> доступны для всех массивов. Одноименные
              свойства и методы, например <kbd>.valueOf</kbd> и
              <kbd>.ToString</kbd>, вызываются из ближайшего прототипа, в этом
              случае из <kbd>Array.prototype</kbd>
            </li>
            <li>
              <a href="https://habr.com/ru/post/263967" target="_blank">
                JavaScript — шаблоны наследования. © Хабр
              </a>
            </li>
            <li>
              <a
                href="https://monsterlessons.com/project/lessons/prototipnoie-nasliedovaniie-v-javascript"
                target="_blank"
              >
                Прототипное наследование в Javascript. © monsterlessons
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>
          9. Всплытие и перехват / погружение события (bubbling & capturing)
        </summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              Принцип <mark>всплытия (bubbling)</mark> заключается в том, что
              когда на элементе происходит событие, обработчики сначала
              срабатывают на нём, потом на его родителе, затем выше и так далее,
              вверх по цепочке предков.
            </li>
            <li>
              <mark>Погружение / перехват (capturing)</mark> описывает 3 фазы
              прохода события: при клике на элемент событие путешествует по
              цепочке родителей сначала вниз к элементу (погружается) -
              <mark>capturing phase</mark>, затем оно достигает целевой элемент
              (фаза цели) - <mark>target phase</mark>, а потом идёт наверх
              (всплытие) - <mark>bubbling stage</mark>, вызывая по пути
              обработчики. Данные стадии, как правило, не используются и
              проходят незаметно для пользователя
            </li>
            <li>
              <a
                href="https://learn.javascript.ru/bubbling-and-capturing"
                target="_blank"
              >
                Всплытие и погружение. © learn.javascript.ru
              </a>
            </li>
            <li>
              <a
                href="http://know-online.com/post/javascript-bubbling"
                target="_blank"
              >
                Всплытие и перехват. © Know Online
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>10. Call, apply, bind</summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              - <kbd>call</kbd> - вызов функции с подменой контекста -
              <kbd>this</kbd> внутри функции
            </li>
            <li>
              - <kbd>apply</kbd> - вызов функции с переменным количеством
              аргументов и с подменой контекста
            </li>
            <li>
              - <kbd>bind</kbd> - создаёт "обёртку" над функцией, которая
              подменяет контекст этой функции. Поведение похоже на
              <kbd>call</kbd> и <kbd>apply</kbd>, но, в отличие от них,
              <kbd>bind</kbd> не вызывает функцию, а лишь возвращает
              <mark>"обёртку"</mark>, которую можно вызвать позже. Также
              <kbd>bind</kbd> умеет подменять не только контекст, но и аргументы
              функции, осуществляя <mark>каррирование</mark> — преобразование
              функции от многих аргументов в набор функций,<mark></mark>
              каждая из которых является функцией от одного аргумента
            </li>
            <li>
              <a
                href="https://ru.stackoverflow.com/questions/426699/bind-call-apply-%D0%B2-%D1%87%D1%91%D0%BC-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0"
                target="_blank"
              >
                bind, call, apply в чём разница? © stack<b>overflow</b>
              </a>
            </li>
            <li>
              <a href="https://habr.com/ru/sandbox/33838" target="_blank">
                JavaScript — методы call и apply. © Хабр
              </a>
            </li>
            <li>
              <a href="https://habr.com/ru/post/199456" target="_blank">
                Bind, Call и Apply в JavaScript. © Хабр
              </a>
            </li>
            <li>
              <a
                href="https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%B4%D1%80%D0%BE%D0%B1%D0%BD%D0%BE-%D0%BE-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B0%D1%85-apply-call-%D0%B8-bind-%D0%BD%D0%B5%D0%BE%D0%B1%D1%85%D0%BE%D0%B4%D0%B8%D0%BC%D1%8B%D1%85-%D0%BA%D0%B0%D0%B6%D0%B4%D0%BE%D0%BC%D1%83-javascript-%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D1%83-ddd5f9b06290"
                target="_blank"
              >
                Подробно о методах apply(), call() и bind(), необходимых каждому
                JavaScript разработчику. © Medium
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>11. Типы данных в JavaScript</summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>В JavaScript есть 8 основных типов:</li>
            <li>
              - <kbd>number</kbd> для любых чисел: целочисленных или чисел с
              плавающей точкой, целочисленные значения ограничены диапазоном
              ±2<sup>53</sup>
            </li>
            <li>- <kbd>bigint</kbd> для целых чисел произвольной длины</li>
            <li>
              - <kbd>string</kbd> для строк. Строка может содержать один или
              больше символов, нет отдельного символьного типа
            </li>
            <li>- <kbd>boolean</kbd> для <kbd>true</kbd>/<kbd>false</kbd></li>
            <li>
              - <kbd>null</kbd> для неизвестных значений – отдельный тип,
              имеющий одно значение <kbd>null</kbd>
            </li>
            <li>
              - <kbd>undefined</kbd> для неприсвоенных значений – отдельный тип,
              имеющий одно значение undefined
            </li>
            <li>- <kbd>object</kbd> для более сложных структур данных</li>
            <li>- <kbd>symbol</kbd> для уникальных идентификаторов</li>
            <li>
              Оператор <kbd>typeof</kbd> позволяет нам увидеть, какой тип данных
              сохранён в переменной:
            </li>

            <li>
              - имеет две формы: <kbd>typeof x</kbd> или <kbd>typeof(x)</kbd>
            </li>
            <li>
              - возвращает строку с именем типа. Например, <mark>"string"</mark>
            </li>
            <li>
              - для <kbd>null</kbd> возвращается <mark>"object"</mark> – это
              ошибка в языке, на самом деле это не объект
            </li>
            <li>
              <a href="https://learn.javascript.ru/types" target="_blank">
                Типы данных. © learn.javascript.ru
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>12. Способы клонирования объекта</summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              Поскольку объекты в JavaScript являются ссылочными значениями, их
              нельзя просто скопировать с помощью знака <kbd>=</kbd>. Но
              существует 3 способа клонирования объекта:
            </li>
            <li>
              - использование <mark>Spread</mark>: неглубокое клонирование
            </li>
            <li>
              - использование <kbd>Object.assign</kbd>: неглубокое клонирование
            </li>
            <li>- использование <mark>JSON</mark>: глубокое клонирование</li>
            <li>
              <a href="https://nuancesprog.ru/p/4443" target="_blank">
                3 способа клонирования объектов в JavaScript. © Nuances of
                programming
              </a>
            </li>
            <li>
              <a
                href="https://medium.com/@stasonmars/%D0%BA%D0%BE%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2-%D0%B2-javascript-d25c261a7aff"
                target="_blank"
              >
                Копирование объектов в JavaScript. © Medium
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>13. Область видимости функции (Scope)</summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              В JavaScript <mark>область видимости (Scope)</mark> — это
              <mark>текущий контекст</mark> в коде. К определению области
              видимости относятся:
            </li>
            <li>- <mark>глобальная</mark> область видимости</li>
            <li>- <mark>локальная</mark> область видимости</li>
            <li>- <mark>функциональная</mark> область видимости</li>
            <li>- <mark>лексическая</mark> область видимости</li>
            <li>- <mark>последовательности</mark> области видимости</li>
            <li>- <mark>замыкания</mark></li>
            <li>- <kbd>this</kbd></li>
            <li>
              - <kbd>.call()</kbd>, <kbd>.apply()</kbd> и <kbd>.bind()</kbd>
            </li>
            <li>- <mark>приватная</mark> область видимости</li>
            <li>- <mark>публичная</mark> область видимости</li>

            <li>
              <a href="https://habr.com/ru/post/239863/" target="_blank">
                Всё, что вы хотели знать об областях видимости в JavaScript (но
                боялись спросить). © Хабр
              </a>
            </li>
            <li>- <mark>блочная</mark> область видимости</li>
            <li>
              -
              <mark
                >немедленно исполняемые функциональные выражения (Immediately
                Invoked Function Expression, IIFE)</mark
              >
            </li>
            <li>
              <a
                href="https://habr.com/ru/company/ruvds/blog/337038/"
                target="_blank"
              >
                Области видимости в JavaScript. © Хабр
              </a>
            </li>
            <li>- <mark>поднятие (hoisting)</mark> функций и переменных</li>
            <li>
              <a
                href="https://itchief.ru/javascript/scope-and-context"
                target="_blank"
              >
                JavaScript - Область видимости и контекст выполнения. © ИТШЕФ
              </a>
            </li>
            <li>
              <a
                href="http://getinstance.info/articles/javascript/variables-scope-in-javascript"
                target="_blank"
              >
                Область видимости переменных в JavaScript. © .getInstance
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>14. Виды сортировок JavaScript и примеры.</summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>Алгоритмы сортировок на JavaScript:</li>
            <li><mark>Пузырьковая</mark> сортировка</li>
            <li>Сортировка <mark>выбором</mark></li>
            <li>Сортировка <mark>вставками</mark></li>
            <li>Сортировка <mark>Шелла</mark></li>
            <li>Сортировка <mark>подсчётом</mark></li>
            <li>Сортировка <mark>расчёской</mark></li>
            <li>Сортировка <mark>слиянием</mark></li>
            <li><mark>Пирамидальная</mark> сортировка</li>
            <li><mark>Быстрая</mark> сортировка</li>
            <li>Сортировка <mark>перемешиванием</mark></li>
            <li><mark>Гномья</mark> сортировка</li>
            <li><mark>Естественная</mark> сортировка</li>
            <li>
              <a
                href="http://mathhelpplanet.com/static.php?p=javascript-algoritmy-sortirovki"
                target="_blank"
                >Алгоритмы сортировок на JavaScript. © Математический форум Math
                Help Planet
              </a>
            </li>
            <li>
              <a href="https://proglib.io/p/sort-gif" target="_blank"
                >Сортировки в гифках: 8 самых популярных алгоритмов. © Proglib
              </a>
            </li>
            <li>
              <a href="https://habr.com/ru/post/127943" target="_blank"
                >Естественная сортировка строк на JavaScript. © Хабр
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>
          15. Что такое <kbd>event.preventDefault</kbd> и
          <kbd>event.stopPropagation</kbd>? Разница между ними.
        </summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              <kbd>event.preventDefault</kbd> —
              <mark>предотвращает действие браузера по умолчанию</mark>, которое
              он выполняет с установленным событием
            </li>
            <li>
              <kbd>event.stopPropagation</kbd> —
              <mark>предотвращает всплывание (bubbling)</mark>
              события в цепочке событий
            </li>
            <li>
              <a
                href="http://stepansuvorov.com/blog/2013/05/%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D0%B5-preventdefault-stoppropagation-%D0%B8-stopimmediatepropagation"
                target="_blank"
              >
                Отличие preventDefault, stopPropagation и
                stopImmediatePropagation. © Stepan Suvorov Blog
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>
          16. Что такое обработчик событий. Способы добавления и удаления
          обработчика событий на элемент
        </summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              <mark>Событие</mark> — это сигнал от браузера о том, что что-то
              произошло. Все DOM-узлы подают такие сигналы (хотя события бывают
              и не только в DOM)
            </li>
            <li>
              Список самых часто используемых DOM-событий для ознакомления:
            </li>
            <li><mark>События мыши:</mark></li>
            <li>
              - <kbd>click</kbd> – происходит, когда кликнули на элемент левой
              кнопкой мыши (на устройствах с сенсорными экранами оно происходит
              при касании)
            </li>
            <li>
              - <kbd>contextmenu</kbd> – происходит, когда кликнули на элемент
              правой кнопкой мыши
            </li>
            <li>
              - <kbd>mouseover</kbd> / <kbd>mouseout</kbd> – когда мышь
              наводится на / покидает элемент
            </li>
            <li>
              - <kbd>mousedown</kbd> / <kbd>mouseup</kbd> – когда нажали /
              отжали кнопку мыши на элементе
            </li>
            <li>- <kbd>mousemove</kbd> – при движении мыши</li>
            <li><mark>События на элементах управления:</mark></li>
            <li>
              - <kbd>submit</kbd> – пользователь отправил форму
              <kbd>&lt;form&gt;</kbd>
            </li>
            <li>
              - <kbd>focus</kbd> – пользователь фокусируется на элементе,
              например нажимает на <kbd>&lt;input&gt;</kbd>
            </li>
            <li><mark>Клавиатурные события:</mark></li>
            <li>
              - <kbd>keydown</kbd> и <kbd>keyup</kbd> – когда пользователь
              нажимает / отпускает клавишу.
            </li>
            <li><mark>События документа:</mark></li>
            <li>
              - <kbd>DOMContentLoaded</kbd> – когда HTML загружен и обработан,
              DOM документа полностью построен и доступен
            </li>
            <li><mark>CSS events:</mark></li>
            <li>- <kbd>transitionend</kbd> – когда CSS-анимация завершена</li>
            <li>
              Событию можно назначить <mark>обработчик</mark>, то есть функцию,
              которая сработает, как только событие произошло. Именно благодаря
              <mark>обработчикам</mark> JavaScript-код может реагировать на
              действия пользователя. Есть несколько способов назначить
              <mark>событию обработчик</mark>:
            </li>
            <li>- атрибут HTML: <kbd>onclick="..."</kbd></li>
            <li>- DOM-свойство: <kbd>elem.onclick = function</kbd></li>
            <li>
              - специальные методы:
              <kbd>elem.addEventListener(event, handler[, phase])</kbd> для
              добавления, <kbd>removeEventListener</kbd> для удаления
            </li>
            <li>
              <a
                href="https://learn.javascript.ru/introduction-browser-events"
                target="_blank"
              >
                Введение в браузерные события. © learn.javascript.ru
              </a>
            </li>
            <li>
              <a
                href="https://professorweb.ru/my/javascript/js_theory/level2/2_5.php"
                target="_blank"
              >
                Обработка событий. © Professor Web
              </a>
            </li>
            <li>
              <a
                href="https://frontender.info/an-introduction-to-dom-events"
                target="_blank"
              >
                Введение в события DOM. © FRONTENDER MAGAZINE
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>19. Что такое Callback?</summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              Простыми словами: <mark>callback</mark> — это функция, которая
              должна быть выполнена после того, как другая функция завершила
              выполнение (отсюда и название: callback – функция обратного
              вызова)
            </li>
            <li>
              Чуть сложнее: В JavaScript функции — это объекты. Поэтому функции
              могут принимать другие функции в качестве аргументов, а также
              функции могут возвращать функции в качестве результата. Функции,
              которые это умеют, называются
              <mark>функциями высшего порядка</mark>. А любая функция, которая
              передается как аргумент, называется
              <mark>callback-функцией</mark>
            </li>
            <li>
              <a
                href="https://ru.hexlet.io/blog/posts/javascript-what-the-heck-is-a-callback"
                target="_blank"
              >
                Что такое callback-функция в JavaScript? © Хекслет
              </a>
            </li>
            <li>
              <a
                href="http://getinstance.info/articles/javascript/callbacks-in-javascript/"
                target="_blank"
              >
                Функции обратного вызова в JavaScript. © .getInstance
              </a>
            </li>
            <li>
              <a href="https://learn.javascript.ru/callbacks" target="_blank">
                Введение: колбэки. © learn.javascript.ru
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>19. Промисы. Объект Promise. Его состояния и методы</summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li><mark>Промис — от английского promise — обещать</mark></li>
            <li>
              <mark>Объект Promise</mark> используется для отложенных и
              асинхронных вычислений
            </li>
            <li>
              <mark>Promise</mark> представляет собой обертку для значения,
              неизвестного на момент создания обещания. Он позволяет
              обрабатывать результаты асинхронных операций так, как если бы они
              были синхронными: вместо конечного результата асинхронного метода
              возвращается обещание, результат которого можно получить в
              некоторый момент в будущем
            </li>
            <li>
              При создании обещание находится в ожидании, состояние
              <mark>pending</mark>, а затем может стать выполнено
              <mark>fulfilled</mark>, вернув полученный результат
              <mark>resolved</mark>, или отклонено <mark>rejected</mark>, вернув
              причину отказа
            </li>
            <li>
              Объект «обещание» создается с помощью конструктора
              <kbd>new Promise(...)</kbd>, которому в качестве аргумента
              передается анонимная функция с <mark>двумя параметрами:</mark>
              <kbd>resolve</kbd>, <kbd>reject</kbd>. Они, в свою очередь, так же
              являются <mark>функциями:</mark> <kbd>resolve()</kbd> — сообщает о
              том, что код выполнен «успешно», <kbd>reject()</kbd> – код
              выполнен с «ошибкой». Это что-то вроде
              <kbd>if(true) {...} else {...}</kbd>
            </li>
            <li>
              В методы <kbd>resolve()</kbd> и <kbd>reject()</kbd> можно
              передавать любые объекты. В метод <kbd>reject()</kbd>, как
              правило, передают объект типа <kbd>Error</kbd> с указанием причины
              ошибки («отклоненного» состояния «обещания»)
            </li>
            <li>У промиса есть 3 состояния:</li>
            <li>- промис в состоянии ожидания <kbd>pending</kbd></li>
            <li>- промис решен <kbd>resolved</kbd></li>
            <li>- промис отклонен <kbd>rejected</kbd></li>
            <li>
              Всякий раз, когда вы создаете объект «обещание», становятся
              доступны <mark>два метода:</mark> <kbd>then()</kbd> и
              <kbd>catch()</kbd>. Используя их, вы можете выполнить нужный код
              при успешном разрешении «обещания» <kbd>resolve(...)</kbd> или же
              код, обрабатывающий ситуацию с «ошибкой» <kbd>reject(...)</kbd>.
            </li>
            <li>
              <a
                href="http://getinstance.info/articles/javascript/grokking-es6-promises-the-four-functions-you-need-to-avoid-callback-hel/"
              >
                Введение в ES6 Promises, или четыре функции, которые вам нужно
                знать. © .getInstance
              </a>
            </li>
            <li>
              <a
                href="http://getinstance.info/articles/javascript/understanding-promises/"
              >
                Три способа понять промисы. © .getInstance
              </a>
            </li>
            <li>
              <a
                href="https://medium.com/@stasonmars/%D0%BF%D1%80%D0%BE%D0%BC%D0%B8%D1%81%D1%8B-%D0%B2-javascript-%D0%B4%D0%BB%D1%8F-%D1%87%D0%B0%D0%B8%CC%86%D0%BD%D0%B8%D0%BA%D0%BE%D0%B2-60bbef963541"
                target="_blank"
              >
                Промисы в JavaScript для чайников. © Medium
              </a>
            </li>
            <li>
              <a href="https://habr.com/ru/company/zerotech/blog/317256">
                Путеводитель по JavaScript Promise для новичков. © Хабр
              </a>
            </li>
            <li>
              <a href="https://learn.javascript.ru/promise-basics">
                Промисы. © learn.javascript.ru
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>18. "proto" и "prototype". Цепочка прототипов</summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              <mark>Прототипы</mark> — это механизм, с помощью которого объекты
              JavaScript наследуют свойства друг от друга
            </li>
            <li>
              JavaScript часто описывают как язык
              <mark>прототипного наследования</mark> — каждый объект, имеет
              объект-прототип, который выступает как шаблон, от которого объект
              наследует методы и свойства. Объект-прототип так же может иметь
              свой прототип и наследовать его свойства и методы и так далее. Это
              часто называется <mark>цепочкой прототипов</mark> и объясняет
              почему одним объектам доступны свойства и методы которые
              определены в других объектах
            </li>
            <li>
              В JavaScript создается связь между экземпляром объекта и его
              прототипом (свойство <kbd>__proto__</kbd>, которое является
              производным от свойства prototype конструктора), а свойства и
              методы обнаруживаются при переходе по цепочке прототипов
            </li>
            <li>
              <a
                href="https://developer.mozilla.org/ru/docs/Learn/JavaScript/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D1%8B/Object_prototypes"
                target="_blank"
              >
                Прототипы объектов. © MDN web docs
              </a>
            </li>
            <li>
              <a href="https://habr.com/ru/post/140810" target="_blank">
                Prototype, proto и оператор new. © Хабр
              </a>
            </li>
            <li>
              <a
                href="https://ru.stackoverflow.com/questions/765445/%D0%92-%D1%87%D0%B5%D0%BC-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D0%B5-proto-%D0%BE%D1%82-prototype"
                target="_blank"
              >
                В чем отличие __proto__ от prototype? © stack<b>overflow</b>
              </a>
            </li>
            <li>
              <a
                href="https://learn.javascript.ru/prototype-inheritance"
                target="_blank"
              >
                Прототипное наследование © learn.javascript.ru
              </a>
            </li>
            <li>
              Свойство <kbd>__proto__</kbd> — ссылка на объект, в котором будет
              искаться свойство, если оно не найдено в текущем объекте
            </li>
            <li>
              <a
                href="http://old.code.mu/javascript/object/proto.html"
                target="_blank"
              >
                Свойство __proto__ © code.mu
              </a>
            </li>
            <li>
              Значение свойства <kbd>prototype</kbd> записывается в прототип
              объекта <kbd>__proto__</kbd> при создании объектов через new
            </li>
            <li>
              <a
                href="http://old.code.mu/javascript/object/prototype.html"
                target="_blank"
              >
                Свойство prototype © code.mu
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>17. Что такое <kbd>async/await</kbd>?</summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              <mark>Async функции</mark>, это функции, которые возвращают
              <mark>промисы</mark>
            </li>
            <li>
              <a
                href="https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%BB%D0%BD%D0%BE%D0%B5-%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B8-%D0%B0%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE-javascript-%D1%81-async-await-ba5f47f4436"
                target="_blank"
              >
                Полное понимание синхронного и асинхронного JavaScript с
                Async/Await. © Medium
              </a>
            </li>
            <li>
              <a
                href="https://tproger.ru/translations/understanding-async-await-in-javascript"
                target="_blank"
              >
                Разбираемся с Async/Await в JavaScript на примерах. © Tproger
              </a>
            </li>
            <li>
              <a
                href="https://habr.com/ru/company/ruvds/blog/414373"
                target="_blank"
              >
                Конструкция async/await в JavaScript: сильные стороны, подводные
                камни и особенности использования. © Хабр
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>20. Что такое замыкание?</summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              <mark>Замыкание</mark> — это функция, объявленная внутри другой
              функции и имеющая доступ к переменным внешней (вмещающей) функции.
              Замыкание имеет доступ сразу к трем областям видимости:
            </li>
            <li>
              - к своей <mark>собственной</mark> области видимости (переменные,
              объявленные внутри замыкания)
            </li>
            <li>
              - к области видимости <mark>внешней</mark> функции (переменные,
              объявленные внутри внешней функции)
            </li>
            <li>- к <mark>глобальной</mark> области видимости</li>
            <li>
              Простыми словами
              <mark
                >замыкание — это функция, описанная внутри другой функции</mark
              >
            </li>
            <li>
              <mark>Внутренняя функция</mark> имеет доступ не только к
              переменным внешней функции, но и к параметрам внешней функции.
              Внутренняя функция не может использовать объект arguments внешней
              функции, однако, имеет доступ к параметрам внешней функции
              напрямую
            </li>
            <li>
              <a
                href="http://getinstance.info/articles/javascript/closures-in-javascript/"
                target="_blank"
              >
                Замыкания в JavaScript. © .getInstance
              </a>
            </li>
            <li>
              <a
                href="https://htmlacademy.ru/blog/boost/frontend/lets-learn-javascript-closures"
                target="_blank"
              >
                Замыкания в JavaScript. © htmlacademy
              </a>
            </li>
            <li>
              <a
                href="https://habr.com/ru/company/ruvds/blog/424967"
                target="_blank"
              >
                Замыкания в JavaScript для начинающих. © Хабр
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>20. Что такое каррирование</summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              <mark>Каррирование или карринг (currying)</mark> в функциональном
              программирование — это преобразование функции с множеством
              аргументов в набор вложенных функций с одним аргументом. При
              вызове <mark>каррированной</mark> функции с передачей ей одного
              аргумента, она возвращает новую функцию, которая ожидает
              поступления следующего аргумента. Новые функции, ожидающие
              следующего аргумента, возвращаются при каждом вызове
              <mark>каррированной</mark> функции — до тех пор, пока функция не
              получит все необходимые ей аргументы. Ранее полученные аргументы,
              благодаря механизму <mark>замыканий</mark>, ждут того момента,
              когда функция получит всё, что ей нужно для выполнения вычислений.
              После получения последнего аргумента функция выполняет вычисления
              и возвращает результат. Говоря о <mark>каррировании</mark>, можно
              сказать, что это процесс превращения функции с несколькими
              аргументами в функцию с меньшей <mark>арностью</mark>.
              <mark>Арность</mark> — это количество аргументов функции
            </li>
            <li>
              <a
                href="https://habr.com/ru/company/ruvds/blog/427295"
                target="_blank"
              >
                Каррирование функций в JavaScript. © Хабр
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>20. Что такое рекурсия?</summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              <mark>Рекурсия</mark> — это когда функция в своём теле вызывает
              саму себя. Функцию, которая вызывает сама себя, называют
              <mark>рекурсивной функцией</mark>. Вызов рекурсивной функции,
              называется <mark>рекурсивным вызовом</mark>.
            </li>
            <li>
              <a
                href="https://puzzleweb.ru/javascript/20_recursiya.php"
                target="_blank"
              >
                JavaScript: Рекурсия. © PuzzleWeb.ru
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>
          21. Принципы ООП: наследование, инкапсуляция, полиморфизм
        </summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              <mark>Наследование</mark> — это свойство системы, позволяющее
              описать новый класс на основе уже существующего с частично или
              полностью заимствующейся функциональностью. Класс, от которого
              производится наследование, называется базовым или родительским.
              Новый класс – потомком, наследником или производным классом. Новый
              класс – потомком, наследником или производным классом.
              <mark>Класс</mark> – это способ описания сущности, определяющий
              состояние и поведение, зависящее от этого состояния, а также
              правила для взаимодействия с данной сущностью (контракт).
            </li>
            <li>
              <mark>Инкапсуляция</mark> — это свойство системы, позволяющее
              объединить данные и методы, работающие с ними, в классе и скрыть
              детали реализации от пользователя. Инкапсуляция неразрывно связана
              с понятием интерфейса класса. По сути, всё то, что не входит в
              интерфейс, инкапсулируется в классе. <mark>Интерфейс</mark> – это
              набор методов класса, доступных для использования другими
              классами.
            </li>
            <li>
              <mark>Полиморфизм</mark> — это свойство системы использовать
              объекты с одинаковым интерфейсом без информации о типе и
              внутренней структуре объекта.
            </li>
            <li>
              <a href="https://habr.com/ru/post/87119" target="_blank">
                ООП с примерами (часть 1). © Хабр
              </a>
            </li>
            <li>
              <a href="https://habr.com/ru/post/87205" target="_blank">
                ООП с примерами (часть 2). © Хабр
              </a>
            </li>
            <li>
              <a
                href="https://tproger.ru/translations/oop-js-fundamentals"
                target="_blank"
              >
                Фундаментальные принципы объектно-ориентированного
                программирования на JavaScript. © Tproger
              </a>
            </li>
            <li>
              <a href="https://habr.com/ru/post/175029" target="_blank">
                Нужны ли в JavaScript классы? © Хабр
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>
          22. Основные паттерны проектирования (Singleton, Module, Prototype,
          Factory, MVC, ...), лучшие практики программирования
        </summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              <mark>Шаблоны проектирования</mark> — это руководства по решению
              повторяющихся проблем. Это не классы, пакеты или библиотеки,
              которые можно было бы подключить к вашему приложению и сидеть в
              ожидании чуда. Они скорее являются методиками, как решать
              определенные проблемы в определенных ситуациях
            </li>
            <li>Википедия описывает их следующим образом:</li>
            <li>
              <mark
                >Шаблон проектирования, или паттерн, в разработке программного
                обеспечения</mark
              >
              — повторяемая архитектурная конструкция, представляющая собой
              решение проблемы проектирования, в рамках некоторого часто
              возникающего контекста.
            </li>
            <li><mark>Нужно иметь ввиду:</mark></li>
            <li>
              - шаблоны проектирования
              <mark>не являются решением всех</mark> ваших <mark>проблем</mark>;
            </li>
            <li>
              - не пытайтесь использовать их в обязательном порядке — это может
              привести к негативным последствиям. Шаблоны — это подходы
              <mark>к решению проблем, а не решения для поиска проблем</mark>
            </li>
            <li>
              - если их правильно использовать в нужных местах, то они
              <mark>могут стать спасением</mark>, а иначе
              <mark>могут привести к ужасному беспорядку</mark>.
            </li>
            <li>
              <mark>Шаблоны</mark> бывают следующих <mark>трех видов</mark>:
            </li>
            <li>- порождающие</li>
            <li>- структурные</li>
            <li>- поведенческие</li>
            <li>
              <mark>Порождающие шаблоны</mark> — шаблоны проектирования, которые
              абстрагируют процесс инстанцирования. Они позволяют сделать
              систему независимой от способа создания, композиции и
              представления объектов. Шаблон, порождающий классы, использует
              наследование, чтобы изменять наследуемый класс, а шаблон,
              порождающий объекты, делегирует инстанцирование другому объекту
            </li>
            <li>
              <mark>Структурные шаблоны</mark> — шаблоны проектирования, в
              которых рассматривается вопрос о том, как из классов и объектов
              образуются более крупные структуры
            </li>
            <li>
              <mark>Поведенческие шаблоны</mark> — шаблоны проектирования,
              определяющие алгоритмы и способы реализации взаимодействия
              различных объектов и классов.
            </li>
            <li>
              <a
                href="https://tproger.ru/translations/design-patterns-simple-words-1"
                target="_blank"
              >
                Шаблоны проектирования простым языком. Часть первая. Порождающие
                шаблон. © Tproger
              </a>
            </li>
            <li>
              <a
                href="https://tproger.ru/translations/design-patterns-simple-words-2"
                target="_blank"
              >
                Шаблоны проектирования простым языком. Часть вторая. Структурные
                шаблоны. © Tproger
              </a>
            </li>
            <li>
              <a
                href="https://tproger.ru/translations/design-patterns-simple-words-3"
                target="_blank"
              >
                Шаблоны проектирования простым языком. Часть третья.
                Поведенческие шаблоны. © Tproger
              </a>
            </li>
            <li><mark>Порождающие паттерны:</mark></li>
            <li>- Singleton (одиночка)</li>
            <li>- Registry (реестр, журнал записей)</li>
            <li>- Multiton (пул «одиночек»)</li>
            <li>- Object pool (пул объектов)</li>
            <li>- Factory (фабрика)</li>
            <li>- Builder (строитель)</li>
            <li>- Prototype (прототип)</li>
            <li>- Factory method (фабричный метод)</li>
            <li>- Lazy initialization (отложенная инициализация)</li>
            <li>- Dependency injection (внедрение зависимости)</li>
            <li>
              <a href="https://proglib.io/p/learn-oop-patterns" target="_blank">
                Паттерны ООП простыми словами: порождающие паттерны. © proglib
              </a>
            </li>
            <li><mark>Структурирующие паттерны:</mark></li>
            <li>- Adapter или wrapper (адаптер, обертка)</li>
            <li>- Bridge (мост)</li>
            <li>- Composite (компоновщик)</li>
            <li>- Decorator (декоратор, оформитель)</li>
            <li>- Facade (фасад)</li>
            <li>- Front controller (единая точка входа)</li>
            <li>- Flyweight (приспособленец)</li>
            <li>- Proxy или surrogate (прокси, заместитель, суррогат)</li>
            <li>
              <a
                href="https://proglib.io/p/learn-oop-patterns-2"
                target="_blank"
              >
                Паттерны ООП простыми словами: структурирующие паттерны. ©
                proglib
              </a>
            </li>
            <li><mark>Паттерны поведения:</mark></li>
            <li>- Chain of responsibility (цепочка обязанностей)</li>
            <li>- Command/action (команда/действие)</li>
            <li>- Iterator (итератор, указатель)</li>
            <li>- Mediator (посредник)</li>
            <li>- Specification (спецификация, определение)</li>
            <li>- Subsumption (категоризация)</li>
            <li>- Memento (хранитель)</li>
            <li>- Observer или Listener (наблюдатель, слушатель)</li>
            <li>- Blackboard (доска объявлений)</li>
            <li>- Servant (слуга)</li>
            <li>- Visitor (посетитель)</li>
            <li>- Single-serving visitor (одноразовый посетитель)</li>
            <li>- Hierarchical visitor (иерархический посетитель)</li>
            <li>- State (состояние)</li>
            <li>- Strategy (стратегия)</li>
            <li>
              <a
                href="https://proglib.io/p/learn-behavioral-patterns"
                target="_blank"
              >
                Паттерны ООП простыми словами: паттерны поведения. © proglib
              </a>
            </li>
            <li><mark>Распространенные паттерны JavaScript:</mark></li>
            <li>
              <a href="https://proglib.io/p/js-design-patterns" target="_blank">
                Шаблоны проектирования в JavaScript простыми словами. © proglib
              </a>
            </li>
            <li>
              <a
                href="https://proglib.io/p/javascript-patterns/"
                target="_blank"
              >
                Паттерны JavaScript: курс, который упростит разработку. ©
                proglib
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>
          23. Что такое Object.create? Привести примеры Object.create
        </summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              <mark>Object.create</mark> - функция, которая создает объект и
              записывает в прототип переданный в параметре объект
            </li>
            <li>
              <a
                href="http://old.code.mu/javascript/object/create.html"
                target="_blank"
              >
                Функции Object.create © code.mu
              </a>
            </li>
            <li>
              <a
                href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/create"
                target="_blank"
              >
                Object.create() © MDN web docs
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>24. Event loop (Callback Queue, Call Stack)</summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              <mark>Event loop — Цикл событий</mark> — решает одну основную
              задачу: наблюдает за стеком вызовов и очередью коллбэков
            </li>
            <li>
              <mark>Callback Queue — Очередь коллбэков</mark> — то место, куда в
              процессе выполнения кода попадают коллбэк-функции
            </li>
            <li>
              <mark>Call Stack — Стек вызовов</mark> — то место, куда в процессе
              выполнения кода попадают так называемые стековые кадры
            </li>
            <li>
              <mark>Memory Heap — Куча</mark> — то место, где происходит
              выделение памяти.
            </li>
            <li>
              <a
                href="https://habr.com/ru/company/ruvds/blog/340508"
                target="_blank"
              >
                Как работает JS: цикл событий, асинхронность и пять способов
                улучшения кода с помощью async / await. © Хабр
              </a>
            </li>
            <li>
              <a
                href="https://developer.mozilla.org/ru/docs/Web/JavaScript/EventLoop"
                target="_blank"
              >
                Параллельная модель и цикл событий. © MDN web docs
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>25. Режим — 'use strict'</summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              На данный момент достаточно иметь общее понимание об этом режиме:
            </li>
            <li>
              - директива "use strict" <mark>переключает</mark> движок в
              «современный» режим, изменяя поведение некоторых встроенных
              функций
            </li>
            <li>
              - строгий режим <mark>включается</mark> путём размещения "use
              strict" в начале скрипта или функции. Некоторые функции языка,
              такие как «классы» и «модули»,
              <mark>автоматически включают</mark> строгий режим
            </li>
            <li>
              -строгий режим <mark>поддерживается</mark> всеми
              <mark>современными браузерами</mark>
            </li>
            <li>
              - рекомендуется <mark>всегда начинать</mark> скрипты с "use
              strict"
            </li>
            <li>
              <a href="https://learn.javascript.ru/strict-mode" target="_blank">
                Строгий режим — "use strict". © learn.javascript.ru
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>
          26. Структуры данных: бинарное дерево, односвязный и двусвязный
          список, стек, очередь
        </summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              <mark>Структура данных</mark> — это контейнер, который хранит
              данные в определенном макете. Этот «макет» позволяет структуре
              данных быть эффективной в некоторых операциях и неэффективной в
              других. Например:
            </li>
            <li>
              - <mark>бинарное дерево</mark> — иерархическая структура данных, в
              которой каждый узел имеет значение (оно же является в данном
              случае и ключом) и ссылки на левого и правого потомка
            </li>
            <li>
              - <mark>связанный список</mark> — массив где каждый элемент
              является отдельным объектом и состоит из двух элементов – данных и
              ссылки на следующий узел:
              <ul>
                <li>
                  › <mark>односвязный список (однонаправленный)</mark> — каждый
                  узел хранит адрес или ссылку на следующий узел в списке и
                  последний узел имеет следующий адрес или ссылку как NULL
                </li>
                <li>
                  › <mark>двусвязный список (двунаправленный)</mark> — две
                  ссылки, связанные с каждым узлом, одним из опорных пунктов на
                  следующий узел и один к предыдущему узлу
                </li>
                <li>
                  › <mark>круговой</mark> — все узлы соединяются, образуя круг.
                  В конце нет NULL. Циклический связанный список может быть
                  одно-или двукратным циклическим связанным списком
                </li>
              </ul>
            </li>
            <li>
              - <mark>стек</mark> — абстрактный тип данных, представляющий собой
              список элементов, организованных по принципу LIFO (англ. last in —
              first out, «последним пришёл — первым вышел»)
            </li>
            <li>
              - <mark>очередь</mark> — хранит элемент последовательным образом.
              Существенное отличие от стека – использование FIFO (First in First
              Out) вместо LIFO. Пример очереди – очередь людей. Последний занял
              последним и будешь, а первый первым ее и покинет.
            </li>
            <li>
              <a href="https://habr.com/ru/post/422259/" target="_blank">
                Основные структуры данных. Матчасть. Азы. © Хабр
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>27. Что такое SessionStorage, LocalStorage и Cookies?</summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              <mark>SessionStorage</mark> — выполняет хранение информации в
              формате ключ-значение в течение определённого промежутка времени
              (сессии). Ключ и значение – это всегда строки. Закрытие вкладки
              или браузера приводит их к удалению. При этом данные в
              <mark>SessionStorage</mark> сохраняются при обновлении страницы.
            </li>
            <li>
              <mark>LocalStorage</mark> – осуществляет хранение информации в
              формате ключ-значение в течении неограниченного времени. Ключ и
              значение – это так же всегда строки. Они сохраняются при
              перезагрузке браузера и компьютера. Их длительность хранения ничем
              не ограничена. Но, хоть эти данные могут храниться бесконечно в
              браузере, обычный пользователь может их очень просто удалить,
              например, выполнив очистку истории (при включенной опции «файлы
              cookie и другие данные сайтов»).
            </li>
            <li>
              <mark>Cookies</mark> — это технология, позволяющая сайтам
              сохранять в браузере небольшую порцию данных (до 4Кбайт).
            </li>
            <li>
              <a
                href="https://itchief.ru/javascript/localstorage-and-sessionstorage"
                target="_blank"
              >
                JavaScript - всё о localStorage и sessionStorage. © ИТШЕФ
              </a>
            </li>
            <li>
              <a href="https://itchief.ru/javascript/cookies" target="_blank">
                JavaScript - Работа с cookies. © ИТШЕФ
              </a>
            </li>
            <li>
              <a
                href="https://ru.hexlet.io/blog/posts/lokalnoe-hranilische-vs-sessionnoe-hranilische-vs-cookie"
                target="_blank"
              >
                Local Storage vs. Session Storage vs. Cookie. © Хекслет
              </a>
            </li>
          </ul>
        </div>
      </details>

      <details>
        <summary>28. Как работает браузер?</summary>
        <div class="answer">
          <span>Ответ:</span>
          <ul class="answer__list">
            <li>
              Основное предназначение <mark>браузера</mark> — отображать
              веб-ресурсы. Для этого на сервер отправляется запрос, а результат
              выводится в окне браузера. Под ресурсами в основном
              подразумеваются HTML-документы, однако это также может быть
              PDF-файл, картинка или иное содержание. Расположение ресурса
              определяется с помощью URI (унифицированного идентификатора
              ресурсов).
            </li>
            <li>
              <a
                href="https://www.html5rocks.com/ru/tutorials/internals/howbrowserswork/"
                target="_blank"
              >
                Принципы работы современных веб-браузеров. © html5rocks
              </a>
            </li>
            <li>
              <a
                href="https://developer.mozilla.org/ru/docs/Web/Performance/How_browsers_work"
                target="_blank"
              >
                Как работают браузеры. © MDN web docs
              </a>
            </li>
          </ul>
        </div>
      </details>
    </section>
  </body>
</html>
